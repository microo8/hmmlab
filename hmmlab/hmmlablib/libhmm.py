# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
Module for creating and manipulating HMMs
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libhmm', [dirname(__file__)])
        except ImportError:
            import _libhmm
            return _libhmm
        if fp is not None:
            try:
                _mod = imp.load_module('_libhmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libhmm = swig_import_helper()
    del swig_import_helper
else:
    import _libhmm
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _libhmm.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _libhmm.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _libhmm.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _libhmm.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _libhmm.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _libhmm.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _libhmm.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _libhmm.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _libhmm.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _libhmm.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _libhmm.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _libhmm.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _libhmm.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _libhmm.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _libhmm.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _libhmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _libhmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectorUInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorUInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorUInt, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorUInt_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorUInt___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorUInt___bool__(self)
    def __len__(self) -> "std::vector< unsigned int >::size_type" : return _libhmm.vectorUInt___len__(self)
    def pop(self) -> "std::vector< unsigned int >::value_type" : return _libhmm.vectorUInt_pop(self)
    def __getslice__(self, *args) -> "std::vector< unsigned int,std::allocator< unsigned int > > *" : return _libhmm.vectorUInt___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorUInt___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorUInt___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorUInt___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &" : return _libhmm.vectorUInt___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorUInt___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorUInt_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorUInt_empty(self)
    def size(self) -> "std::vector< unsigned int >::size_type" : return _libhmm.vectorUInt_size(self)
    def clear(self) -> "void" : return _libhmm.vectorUInt_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorUInt_swap(self, *args)
    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type" : return _libhmm.vectorUInt_get_allocator(self)
    def begin(self) -> "std::vector< unsigned int >::iterator" : return _libhmm.vectorUInt_begin(self)
    def end(self) -> "std::vector< unsigned int >::iterator" : return _libhmm.vectorUInt_end(self)
    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator" : return _libhmm.vectorUInt_rbegin(self)
    def rend(self) -> "std::vector< unsigned int >::reverse_iterator" : return _libhmm.vectorUInt_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorUInt_pop_back(self)
    def erase(self, *args) -> "std::vector< unsigned int >::iterator" : return _libhmm.vectorUInt_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorUInt(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorUInt_push_back(self, *args)
    def front(self) -> "std::vector< unsigned int >::value_type const &" : return _libhmm.vectorUInt_front(self)
    def back(self) -> "std::vector< unsigned int >::value_type const &" : return _libhmm.vectorUInt_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorUInt_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorUInt_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorUInt_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorUInt_reserve(self, *args)
    def capacity(self) -> "std::vector< unsigned int >::size_type" : return _libhmm.vectorUInt_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorUInt
    __del__ = lambda self : None;
vectorUInt_swigregister = _libhmm.vectorUInt_swigregister
vectorUInt_swigregister(vectorUInt)

class ListUInt(vectorUInt):
    __swig_setmethods__ = {}
    for _s in [vectorUInt]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListUInt, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorUInt]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListUInt, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListUInt
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListUInt(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< unsigned int > &" : return _libhmm.ListUInt___iadd__(self, *args)
    def __add__(self, *args) -> "List< unsigned int > &" : return _libhmm.ListUInt___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListUInt_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListUInt_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListUInt_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListUInt_index(self, *args)
    def c_array(self) -> "unsigned int *" : return _libhmm.ListUInt_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListUInt_listsort(self)
ListUInt_swigregister = _libhmm.ListUInt_swigregister
ListUInt_swigregister(ListUInt)

class vectorDouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorDouble, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorDouble_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorDouble___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorDouble___bool__(self)
    def __len__(self) -> "std::vector< double >::size_type" : return _libhmm.vectorDouble___len__(self)
    def pop(self) -> "std::vector< double >::value_type" : return _libhmm.vectorDouble_pop(self)
    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" : return _libhmm.vectorDouble___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorDouble___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorDouble___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorDouble___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" : return _libhmm.vectorDouble___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorDouble___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorDouble_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorDouble_empty(self)
    def size(self) -> "std::vector< double >::size_type" : return _libhmm.vectorDouble_size(self)
    def clear(self) -> "void" : return _libhmm.vectorDouble_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorDouble_swap(self, *args)
    def get_allocator(self) -> "std::vector< double >::allocator_type" : return _libhmm.vectorDouble_get_allocator(self)
    def begin(self) -> "std::vector< double >::iterator" : return _libhmm.vectorDouble_begin(self)
    def end(self) -> "std::vector< double >::iterator" : return _libhmm.vectorDouble_end(self)
    def rbegin(self) -> "std::vector< double >::reverse_iterator" : return _libhmm.vectorDouble_rbegin(self)
    def rend(self) -> "std::vector< double >::reverse_iterator" : return _libhmm.vectorDouble_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorDouble_pop_back(self)
    def erase(self, *args) -> "std::vector< double >::iterator" : return _libhmm.vectorDouble_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorDouble_push_back(self, *args)
    def front(self) -> "std::vector< double >::value_type const &" : return _libhmm.vectorDouble_front(self)
    def back(self) -> "std::vector< double >::value_type const &" : return _libhmm.vectorDouble_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorDouble_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorDouble_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorDouble_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorDouble_reserve(self, *args)
    def capacity(self) -> "std::vector< double >::size_type" : return _libhmm.vectorDouble_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorDouble
    __del__ = lambda self : None;
vectorDouble_swigregister = _libhmm.vectorDouble_swigregister
vectorDouble_swigregister(vectorDouble)

class ListDouble(vectorDouble):
    __swig_setmethods__ = {}
    for _s in [vectorDouble]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorDouble]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListDouble, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListDouble
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< double > &" : return _libhmm.ListDouble___iadd__(self, *args)
    def __add__(self, *args) -> "List< double > &" : return _libhmm.ListDouble___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListDouble_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListDouble_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListDouble_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListDouble_index(self, *args)
    def c_array(self) -> "double *" : return _libhmm.ListDouble_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListDouble_listsort(self)
ListDouble_swigregister = _libhmm.ListDouble_swigregister
ListDouble_swigregister(ListDouble)

class vectorHMMLab_Object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorHMMLab_Object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorHMMLab_Object, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorHMMLab_Object_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorHMMLab_Object___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorHMMLab_Object___bool__(self)
    def __len__(self) -> "std::vector< HMMLab_Object * >::size_type" : return _libhmm.vectorHMMLab_Object___len__(self)
    def pop(self) -> "std::vector< HMMLab_Object * >::value_type" : return _libhmm.vectorHMMLab_Object_pop(self)
    def __getslice__(self, *args) -> "std::vector< HMMLab_Object *,std::allocator< HMMLab_Object * > > *" : return _libhmm.vectorHMMLab_Object___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< HMMLab_Object * >::value_type" : return _libhmm.vectorHMMLab_Object___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorHMMLab_Object_empty(self)
    def size(self) -> "std::vector< HMMLab_Object * >::size_type" : return _libhmm.vectorHMMLab_Object_size(self)
    def clear(self) -> "void" : return _libhmm.vectorHMMLab_Object_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_swap(self, *args)
    def get_allocator(self) -> "std::vector< HMMLab_Object * >::allocator_type" : return _libhmm.vectorHMMLab_Object_get_allocator(self)
    def begin(self) -> "std::vector< HMMLab_Object * >::iterator" : return _libhmm.vectorHMMLab_Object_begin(self)
    def end(self) -> "std::vector< HMMLab_Object * >::iterator" : return _libhmm.vectorHMMLab_Object_end(self)
    def rbegin(self) -> "std::vector< HMMLab_Object * >::reverse_iterator" : return _libhmm.vectorHMMLab_Object_rbegin(self)
    def rend(self) -> "std::vector< HMMLab_Object * >::reverse_iterator" : return _libhmm.vectorHMMLab_Object_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorHMMLab_Object_pop_back(self)
    def erase(self, *args) -> "std::vector< HMMLab_Object * >::iterator" : return _libhmm.vectorHMMLab_Object_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorHMMLab_Object(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_push_back(self, *args)
    def front(self) -> "std::vector< HMMLab_Object * >::value_type" : return _libhmm.vectorHMMLab_Object_front(self)
    def back(self) -> "std::vector< HMMLab_Object * >::value_type" : return _libhmm.vectorHMMLab_Object_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorHMMLab_Object_reserve(self, *args)
    def capacity(self) -> "std::vector< HMMLab_Object * >::size_type" : return _libhmm.vectorHMMLab_Object_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorHMMLab_Object
    __del__ = lambda self : None;
vectorHMMLab_Object_swigregister = _libhmm.vectorHMMLab_Object_swigregister
vectorHMMLab_Object_swigregister(vectorHMMLab_Object)

class ListHMMLab_Object(vectorHMMLab_Object):
    __swig_setmethods__ = {}
    for _s in [vectorHMMLab_Object]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListHMMLab_Object, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorHMMLab_Object]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListHMMLab_Object, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListHMMLab_Object
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListHMMLab_Object(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< HMMLab_Object * > &" : return _libhmm.ListHMMLab_Object___iadd__(self, *args)
    def __add__(self, *args) -> "List< HMMLab_Object * > &" : return _libhmm.ListHMMLab_Object___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListHMMLab_Object_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListHMMLab_Object_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListHMMLab_Object_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListHMMLab_Object_index(self, *args)
    def c_array(self) -> "HMMLab_Object **" : return _libhmm.ListHMMLab_Object_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListHMMLab_Object_listsort(self)
ListHMMLab_Object_swigregister = _libhmm.ListHMMLab_Object_swigregister
ListHMMLab_Object_swigregister(ListHMMLab_Object)

class vectorModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorModel, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorModel_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorModel___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorModel___bool__(self)
    def __len__(self) -> "std::vector< Model * >::size_type" : return _libhmm.vectorModel___len__(self)
    def pop(self) -> "std::vector< Model * >::value_type" : return _libhmm.vectorModel_pop(self)
    def __getslice__(self, *args) -> "std::vector< Model *,std::allocator< Model * > > *" : return _libhmm.vectorModel___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorModel___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorModel___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorModel___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< Model * >::value_type" : return _libhmm.vectorModel___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorModel___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorModel_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorModel_empty(self)
    def size(self) -> "std::vector< Model * >::size_type" : return _libhmm.vectorModel_size(self)
    def clear(self) -> "void" : return _libhmm.vectorModel_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorModel_swap(self, *args)
    def get_allocator(self) -> "std::vector< Model * >::allocator_type" : return _libhmm.vectorModel_get_allocator(self)
    def begin(self) -> "std::vector< Model * >::iterator" : return _libhmm.vectorModel_begin(self)
    def end(self) -> "std::vector< Model * >::iterator" : return _libhmm.vectorModel_end(self)
    def rbegin(self) -> "std::vector< Model * >::reverse_iterator" : return _libhmm.vectorModel_rbegin(self)
    def rend(self) -> "std::vector< Model * >::reverse_iterator" : return _libhmm.vectorModel_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorModel_pop_back(self)
    def erase(self, *args) -> "std::vector< Model * >::iterator" : return _libhmm.vectorModel_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorModel(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorModel_push_back(self, *args)
    def front(self) -> "std::vector< Model * >::value_type" : return _libhmm.vectorModel_front(self)
    def back(self) -> "std::vector< Model * >::value_type" : return _libhmm.vectorModel_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorModel_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorModel_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorModel_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorModel_reserve(self, *args)
    def capacity(self) -> "std::vector< Model * >::size_type" : return _libhmm.vectorModel_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorModel
    __del__ = lambda self : None;
vectorModel_swigregister = _libhmm.vectorModel_swigregister
vectorModel_swigregister(vectorModel)

class ListModel(vectorModel):
    __swig_setmethods__ = {}
    for _s in [vectorModel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListModel, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorModel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListModel, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListModel
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListModel(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< Model * > &" : return _libhmm.ListModel___iadd__(self, *args)
    def __add__(self, *args) -> "List< Model * > &" : return _libhmm.ListModel___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListModel_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListModel_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListModel_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListModel_index(self, *args)
    def c_array(self) -> "Model **" : return _libhmm.ListModel_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListModel_listsort(self)
ListModel_swigregister = _libhmm.ListModel_swigregister
ListModel_swigregister(ListModel)

class vectorState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorState, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorState_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorState___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorState___bool__(self)
    def __len__(self) -> "std::vector< State * >::size_type" : return _libhmm.vectorState___len__(self)
    def pop(self) -> "std::vector< State * >::value_type" : return _libhmm.vectorState_pop(self)
    def __getslice__(self, *args) -> "std::vector< State *,std::allocator< State * > > *" : return _libhmm.vectorState___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorState___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorState___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorState___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< State * >::value_type" : return _libhmm.vectorState___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorState___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorState_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorState_empty(self)
    def size(self) -> "std::vector< State * >::size_type" : return _libhmm.vectorState_size(self)
    def clear(self) -> "void" : return _libhmm.vectorState_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorState_swap(self, *args)
    def get_allocator(self) -> "std::vector< State * >::allocator_type" : return _libhmm.vectorState_get_allocator(self)
    def begin(self) -> "std::vector< State * >::iterator" : return _libhmm.vectorState_begin(self)
    def end(self) -> "std::vector< State * >::iterator" : return _libhmm.vectorState_end(self)
    def rbegin(self) -> "std::vector< State * >::reverse_iterator" : return _libhmm.vectorState_rbegin(self)
    def rend(self) -> "std::vector< State * >::reverse_iterator" : return _libhmm.vectorState_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorState_pop_back(self)
    def erase(self, *args) -> "std::vector< State * >::iterator" : return _libhmm.vectorState_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorState(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorState_push_back(self, *args)
    def front(self) -> "std::vector< State * >::value_type" : return _libhmm.vectorState_front(self)
    def back(self) -> "std::vector< State * >::value_type" : return _libhmm.vectorState_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorState_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorState_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorState_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorState_reserve(self, *args)
    def capacity(self) -> "std::vector< State * >::size_type" : return _libhmm.vectorState_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorState
    __del__ = lambda self : None;
vectorState_swigregister = _libhmm.vectorState_swigregister
vectorState_swigregister(vectorState)

class ListState(vectorState):
    __swig_setmethods__ = {}
    for _s in [vectorState]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListState, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorState]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListState, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListState
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListState(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< State * > &" : return _libhmm.ListState___iadd__(self, *args)
    def __add__(self, *args) -> "List< State * > &" : return _libhmm.ListState___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListState_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListState_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListState_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListState_index(self, *args)
    def c_array(self) -> "State **" : return _libhmm.ListState_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListState_listsort(self)
ListState_swigregister = _libhmm.ListState_swigregister
ListState_swigregister(ListState)

class vectorStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorStream, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorStream_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorStream___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorStream___bool__(self)
    def __len__(self) -> "std::vector< Stream * >::size_type" : return _libhmm.vectorStream___len__(self)
    def pop(self) -> "std::vector< Stream * >::value_type" : return _libhmm.vectorStream_pop(self)
    def __getslice__(self, *args) -> "std::vector< Stream *,std::allocator< Stream * > > *" : return _libhmm.vectorStream___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorStream___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorStream___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorStream___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< Stream * >::value_type" : return _libhmm.vectorStream___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorStream___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorStream_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorStream_empty(self)
    def size(self) -> "std::vector< Stream * >::size_type" : return _libhmm.vectorStream_size(self)
    def clear(self) -> "void" : return _libhmm.vectorStream_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorStream_swap(self, *args)
    def get_allocator(self) -> "std::vector< Stream * >::allocator_type" : return _libhmm.vectorStream_get_allocator(self)
    def begin(self) -> "std::vector< Stream * >::iterator" : return _libhmm.vectorStream_begin(self)
    def end(self) -> "std::vector< Stream * >::iterator" : return _libhmm.vectorStream_end(self)
    def rbegin(self) -> "std::vector< Stream * >::reverse_iterator" : return _libhmm.vectorStream_rbegin(self)
    def rend(self) -> "std::vector< Stream * >::reverse_iterator" : return _libhmm.vectorStream_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorStream_pop_back(self)
    def erase(self, *args) -> "std::vector< Stream * >::iterator" : return _libhmm.vectorStream_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorStream(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorStream_push_back(self, *args)
    def front(self) -> "std::vector< Stream * >::value_type" : return _libhmm.vectorStream_front(self)
    def back(self) -> "std::vector< Stream * >::value_type" : return _libhmm.vectorStream_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorStream_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorStream_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorStream_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorStream_reserve(self, *args)
    def capacity(self) -> "std::vector< Stream * >::size_type" : return _libhmm.vectorStream_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorStream
    __del__ = lambda self : None;
vectorStream_swigregister = _libhmm.vectorStream_swigregister
vectorStream_swigregister(vectorStream)

class ListStream(vectorStream):
    __swig_setmethods__ = {}
    for _s in [vectorStream]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListStream, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorStream]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListStream, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListStream
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListStream(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< Stream * > &" : return _libhmm.ListStream___iadd__(self, *args)
    def __add__(self, *args) -> "List< Stream * > &" : return _libhmm.ListStream___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListStream_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListStream_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListStream_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListStream_index(self, *args)
    def c_array(self) -> "Stream **" : return _libhmm.ListStream_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListStream_listsort(self)
ListStream_swigregister = _libhmm.ListStream_swigregister
ListStream_swigregister(ListStream)

class vectorGaussian(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorGaussian, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorGaussian, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorGaussian_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorGaussian___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorGaussian___bool__(self)
    def __len__(self) -> "std::vector< Gaussian * >::size_type" : return _libhmm.vectorGaussian___len__(self)
    def pop(self) -> "std::vector< Gaussian * >::value_type" : return _libhmm.vectorGaussian_pop(self)
    def __getslice__(self, *args) -> "std::vector< Gaussian *,std::allocator< Gaussian * > > *" : return _libhmm.vectorGaussian___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorGaussian___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorGaussian___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorGaussian___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< Gaussian * >::value_type" : return _libhmm.vectorGaussian___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorGaussian___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorGaussian_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorGaussian_empty(self)
    def size(self) -> "std::vector< Gaussian * >::size_type" : return _libhmm.vectorGaussian_size(self)
    def clear(self) -> "void" : return _libhmm.vectorGaussian_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorGaussian_swap(self, *args)
    def get_allocator(self) -> "std::vector< Gaussian * >::allocator_type" : return _libhmm.vectorGaussian_get_allocator(self)
    def begin(self) -> "std::vector< Gaussian * >::iterator" : return _libhmm.vectorGaussian_begin(self)
    def end(self) -> "std::vector< Gaussian * >::iterator" : return _libhmm.vectorGaussian_end(self)
    def rbegin(self) -> "std::vector< Gaussian * >::reverse_iterator" : return _libhmm.vectorGaussian_rbegin(self)
    def rend(self) -> "std::vector< Gaussian * >::reverse_iterator" : return _libhmm.vectorGaussian_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorGaussian_pop_back(self)
    def erase(self, *args) -> "std::vector< Gaussian * >::iterator" : return _libhmm.vectorGaussian_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorGaussian(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorGaussian_push_back(self, *args)
    def front(self) -> "std::vector< Gaussian * >::value_type" : return _libhmm.vectorGaussian_front(self)
    def back(self) -> "std::vector< Gaussian * >::value_type" : return _libhmm.vectorGaussian_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorGaussian_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorGaussian_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorGaussian_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorGaussian_reserve(self, *args)
    def capacity(self) -> "std::vector< Gaussian * >::size_type" : return _libhmm.vectorGaussian_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorGaussian
    __del__ = lambda self : None;
vectorGaussian_swigregister = _libhmm.vectorGaussian_swigregister
vectorGaussian_swigregister(vectorGaussian)

class ListGaussian(vectorGaussian):
    __swig_setmethods__ = {}
    for _s in [vectorGaussian]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListGaussian, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorGaussian]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListGaussian, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListGaussian
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListGaussian(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< Gaussian * > &" : return _libhmm.ListGaussian___iadd__(self, *args)
    def __add__(self, *args) -> "List< Gaussian * > &" : return _libhmm.ListGaussian___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListGaussian_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListGaussian_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListGaussian_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListGaussian_index(self, *args)
    def c_array(self) -> "Gaussian **" : return _libhmm.ListGaussian_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListGaussian_listsort(self)
ListGaussian_swigregister = _libhmm.ListGaussian_swigregister
ListGaussian_swigregister(ListGaussian)

class vectorStreamArea(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorStreamArea, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorStreamArea, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorStreamArea_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorStreamArea___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorStreamArea___bool__(self)
    def __len__(self) -> "std::vector< StreamArea * >::size_type" : return _libhmm.vectorStreamArea___len__(self)
    def pop(self) -> "std::vector< StreamArea * >::value_type" : return _libhmm.vectorStreamArea_pop(self)
    def __getslice__(self, *args) -> "std::vector< StreamArea *,std::allocator< StreamArea * > > *" : return _libhmm.vectorStreamArea___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorStreamArea___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorStreamArea___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorStreamArea___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< StreamArea * >::value_type" : return _libhmm.vectorStreamArea___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorStreamArea___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorStreamArea_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorStreamArea_empty(self)
    def size(self) -> "std::vector< StreamArea * >::size_type" : return _libhmm.vectorStreamArea_size(self)
    def clear(self) -> "void" : return _libhmm.vectorStreamArea_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorStreamArea_swap(self, *args)
    def get_allocator(self) -> "std::vector< StreamArea * >::allocator_type" : return _libhmm.vectorStreamArea_get_allocator(self)
    def begin(self) -> "std::vector< StreamArea * >::iterator" : return _libhmm.vectorStreamArea_begin(self)
    def end(self) -> "std::vector< StreamArea * >::iterator" : return _libhmm.vectorStreamArea_end(self)
    def rbegin(self) -> "std::vector< StreamArea * >::reverse_iterator" : return _libhmm.vectorStreamArea_rbegin(self)
    def rend(self) -> "std::vector< StreamArea * >::reverse_iterator" : return _libhmm.vectorStreamArea_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorStreamArea_pop_back(self)
    def erase(self, *args) -> "std::vector< StreamArea * >::iterator" : return _libhmm.vectorStreamArea_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorStreamArea(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorStreamArea_push_back(self, *args)
    def front(self) -> "std::vector< StreamArea * >::value_type" : return _libhmm.vectorStreamArea_front(self)
    def back(self) -> "std::vector< StreamArea * >::value_type" : return _libhmm.vectorStreamArea_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorStreamArea_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorStreamArea_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorStreamArea_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorStreamArea_reserve(self, *args)
    def capacity(self) -> "std::vector< StreamArea * >::size_type" : return _libhmm.vectorStreamArea_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorStreamArea
    __del__ = lambda self : None;
vectorStreamArea_swigregister = _libhmm.vectorStreamArea_swigregister
vectorStreamArea_swigregister(vectorStreamArea)

class ListStreamArea(vectorStreamArea):
    __swig_setmethods__ = {}
    for _s in [vectorStreamArea]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListStreamArea, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorStreamArea]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListStreamArea, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListStreamArea
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListStreamArea(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< StreamArea * > &" : return _libhmm.ListStreamArea___iadd__(self, *args)
    def __add__(self, *args) -> "List< StreamArea * > &" : return _libhmm.ListStreamArea___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListStreamArea_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListStreamArea_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListStreamArea_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListStreamArea_index(self, *args)
    def c_array(self) -> "StreamArea **" : return _libhmm.ListStreamArea_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListStreamArea_listsort(self)
ListStreamArea_swigregister = _libhmm.ListStreamArea_swigregister
ListStreamArea_swigregister(ListStreamArea)

class vectorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorVector, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.vectorVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.vectorVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.vectorVector___bool__(self)
    def __len__(self) -> "std::vector< Vector * >::size_type" : return _libhmm.vectorVector___len__(self)
    def pop(self) -> "std::vector< Vector * >::value_type" : return _libhmm.vectorVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< Vector *,std::allocator< Vector * > > *" : return _libhmm.vectorVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _libhmm.vectorVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _libhmm.vectorVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.vectorVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< Vector * >::value_type" : return _libhmm.vectorVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _libhmm.vectorVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.vectorVector_append(self, *args)
    def empty(self) -> "bool" : return _libhmm.vectorVector_empty(self)
    def size(self) -> "std::vector< Vector * >::size_type" : return _libhmm.vectorVector_size(self)
    def clear(self) -> "void" : return _libhmm.vectorVector_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.vectorVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< Vector * >::allocator_type" : return _libhmm.vectorVector_get_allocator(self)
    def begin(self) -> "std::vector< Vector * >::iterator" : return _libhmm.vectorVector_begin(self)
    def end(self) -> "std::vector< Vector * >::iterator" : return _libhmm.vectorVector_end(self)
    def rbegin(self) -> "std::vector< Vector * >::reverse_iterator" : return _libhmm.vectorVector_rbegin(self)
    def rend(self) -> "std::vector< Vector * >::reverse_iterator" : return _libhmm.vectorVector_rend(self)
    def pop_back(self) -> "void" : return _libhmm.vectorVector_pop_back(self)
    def erase(self, *args) -> "std::vector< Vector * >::iterator" : return _libhmm.vectorVector_erase(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_vectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _libhmm.vectorVector_push_back(self, *args)
    def front(self) -> "std::vector< Vector * >::value_type" : return _libhmm.vectorVector_front(self)
    def back(self) -> "std::vector< Vector * >::value_type" : return _libhmm.vectorVector_back(self)
    def assign(self, *args) -> "void" : return _libhmm.vectorVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _libhmm.vectorVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _libhmm.vectorVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _libhmm.vectorVector_reserve(self, *args)
    def capacity(self) -> "std::vector< Vector * >::size_type" : return _libhmm.vectorVector_capacity(self)
    __swig_destroy__ = _libhmm.delete_vectorVector
    __del__ = lambda self : None;
vectorVector_swigregister = _libhmm.vectorVector_swigregister
vectorVector_swigregister(vectorVector)

class ListVector(vectorVector):
    __swig_setmethods__ = {}
    for _s in [vectorVector]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListVector, name, value)
    __swig_getmethods__ = {}
    for _s in [vectorVector]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ListVector, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhmm.delete_ListVector
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _libhmm.new_ListVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def __iadd__(self, *args) -> "List< Vector * > &" : return _libhmm.ListVector___iadd__(self, *args)
    def __add__(self, *args) -> "List< Vector * > &" : return _libhmm.ListVector___add__(self, *args)
    def append(self, *args) -> "void" : return _libhmm.ListVector_append(self, *args)
    def remove(self, *args) -> "void" : return _libhmm.ListVector_remove(self, *args)
    def remove_value(self, *args) -> "void" : return _libhmm.ListVector_remove_value(self, *args)
    def index(self, *args) -> "int" : return _libhmm.ListVector_index(self, *args)
    def c_array(self) -> "Vector **" : return _libhmm.ListVector_c_array(self)
    def listsort(self) -> "void" : return _libhmm.ListVector_listsort(self)
ListVector_swigregister = _libhmm.ListVector_swigregister
ListVector_swigregister(ListVector)

class mapStringHMMLab_Object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapStringHMMLab_Object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapStringHMMLab_Object, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.mapStringHMMLab_Object_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.mapStringHMMLab_Object___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.mapStringHMMLab_Object___bool__(self)
    def __len__(self) -> "std::map< std::string,HMMLab_Object * >::size_type" : return _libhmm.mapStringHMMLab_Object___len__(self)
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args) -> "std::map< std::string,HMMLab_Object * >::mapped_type const &" : return _libhmm.mapStringHMMLab_Object___getitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _libhmm.mapStringHMMLab_Object___delitem__(self, *args)
    def has_key(self, *args) -> "bool" : return _libhmm.mapStringHMMLab_Object_has_key(self, *args)
    def keys(self) -> "PyObject *" : return _libhmm.mapStringHMMLab_Object_keys(self)
    def values(self) -> "PyObject *" : return _libhmm.mapStringHMMLab_Object_values(self)
    def items(self) -> "PyObject *" : return _libhmm.mapStringHMMLab_Object_items(self)
    def __contains__(self, *args) -> "bool" : return _libhmm.mapStringHMMLab_Object___contains__(self, *args)
    def key_iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.mapStringHMMLab_Object_key_iterator(self)
    def value_iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.mapStringHMMLab_Object_value_iterator(self)
    def __setitem__(self, *args) -> "void" : return _libhmm.mapStringHMMLab_Object___setitem__(self, *args)
    def asdict(self) -> "PyObject *" : return _libhmm.mapStringHMMLab_Object_asdict(self)
    def __init__(self, *args): 
        this = _libhmm.new_mapStringHMMLab_Object(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _libhmm.mapStringHMMLab_Object_empty(self)
    def size(self) -> "std::map< std::string,HMMLab_Object * >::size_type" : return _libhmm.mapStringHMMLab_Object_size(self)
    def clear(self) -> "void" : return _libhmm.mapStringHMMLab_Object_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.mapStringHMMLab_Object_swap(self, *args)
    def get_allocator(self) -> "std::map< std::string,HMMLab_Object * >::allocator_type" : return _libhmm.mapStringHMMLab_Object_get_allocator(self)
    def begin(self) -> "std::map< std::string,HMMLab_Object * >::iterator" : return _libhmm.mapStringHMMLab_Object_begin(self)
    def end(self) -> "std::map< std::string,HMMLab_Object * >::iterator" : return _libhmm.mapStringHMMLab_Object_end(self)
    def rbegin(self) -> "std::map< std::string,HMMLab_Object * >::reverse_iterator" : return _libhmm.mapStringHMMLab_Object_rbegin(self)
    def rend(self) -> "std::map< std::string,HMMLab_Object * >::reverse_iterator" : return _libhmm.mapStringHMMLab_Object_rend(self)
    def count(self, *args) -> "std::map< std::string,HMMLab_Object * >::size_type" : return _libhmm.mapStringHMMLab_Object_count(self, *args)
    def erase(self, *args) -> "void" : return _libhmm.mapStringHMMLab_Object_erase(self, *args)
    def find(self, *args) -> "std::map< std::string,HMMLab_Object * >::iterator" : return _libhmm.mapStringHMMLab_Object_find(self, *args)
    def lower_bound(self, *args) -> "std::map< std::string,HMMLab_Object * >::iterator" : return _libhmm.mapStringHMMLab_Object_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::map< std::string,HMMLab_Object * >::iterator" : return _libhmm.mapStringHMMLab_Object_upper_bound(self, *args)
    __swig_destroy__ = _libhmm.delete_mapStringHMMLab_Object
    __del__ = lambda self : None;
mapStringHMMLab_Object_swigregister = _libhmm.mapStringHMMLab_Object_swigregister
mapStringHMMLab_Object_swigregister(mapStringHMMLab_Object)

class DictStringHMMLab_Object(mapStringHMMLab_Object):
    __swig_setmethods__ = {}
    for _s in [mapStringHMMLab_Object]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictStringHMMLab_Object, name, value)
    __swig_getmethods__ = {}
    for _s in [mapStringHMMLab_Object]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DictStringHMMLab_Object, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _libhmm.new_DictStringHMMLab_Object()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_DictStringHMMLab_Object
    __del__ = lambda self : None;
    def update(self, *args) -> "void" : return _libhmm.DictStringHMMLab_Object_update(self, *args)
    def keys(self) -> "List< std::string >" : return _libhmm.DictStringHMMLab_Object_keys(self)
DictStringHMMLab_Object_swigregister = _libhmm.DictStringHMMLab_Object_swigregister
DictStringHMMLab_Object_swigregister(DictStringHMMLab_Object)

class setGaussian(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, setGaussian, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, setGaussian, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _libhmm.setGaussian_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _libhmm.setGaussian___nonzero__(self)
    def __bool__(self) -> "bool" : return _libhmm.setGaussian___bool__(self)
    def __len__(self) -> "std::set< Gaussian * >::size_type" : return _libhmm.setGaussian___len__(self)
    def append(self, *args) -> "void" : return _libhmm.setGaussian_append(self, *args)
    def __contains__(self, *args) -> "bool" : return _libhmm.setGaussian___contains__(self, *args)
    def __getitem__(self, *args) -> "std::set< Gaussian * >::value_type" : return _libhmm.setGaussian___getitem__(self, *args)
    def add(self, *args) -> "void" : return _libhmm.setGaussian_add(self, *args)
    def discard(self, *args) -> "void" : return _libhmm.setGaussian_discard(self, *args)
    def __init__(self, *args): 
        this = _libhmm.new_setGaussian(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _libhmm.setGaussian_empty(self)
    def size(self) -> "std::set< Gaussian * >::size_type" : return _libhmm.setGaussian_size(self)
    def clear(self) -> "void" : return _libhmm.setGaussian_clear(self)
    def swap(self, *args) -> "void" : return _libhmm.setGaussian_swap(self, *args)
    def count(self, *args) -> "std::set< Gaussian * >::size_type" : return _libhmm.setGaussian_count(self, *args)
    def begin(self) -> "std::set< Gaussian * >::iterator" : return _libhmm.setGaussian_begin(self)
    def end(self) -> "std::set< Gaussian * >::iterator" : return _libhmm.setGaussian_end(self)
    def rbegin(self) -> "std::set< Gaussian * >::reverse_iterator" : return _libhmm.setGaussian_rbegin(self)
    def rend(self) -> "std::set< Gaussian * >::reverse_iterator" : return _libhmm.setGaussian_rend(self)
    def erase(self, *args) -> "void" : return _libhmm.setGaussian_erase(self, *args)
    def find(self, *args) -> "std::set< Gaussian * >::iterator" : return _libhmm.setGaussian_find(self, *args)
    def lower_bound(self, *args) -> "std::set< Gaussian * >::iterator" : return _libhmm.setGaussian_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::set< Gaussian * >::iterator" : return _libhmm.setGaussian_upper_bound(self, *args)
    def equal_range(self, *args) -> "std::pair< std::set< Gaussian * >::iterator,std::set< Gaussian * >::iterator >" : return _libhmm.setGaussian_equal_range(self, *args)
    def insert(self, *args) -> "std::pair< std::set< Gaussian * >::iterator,bool >" : return _libhmm.setGaussian_insert(self, *args)
    __swig_destroy__ = _libhmm.delete_setGaussian
    __del__ = lambda self : None;
setGaussian_swigregister = _libhmm.setGaussian_swigregister
setGaussian_swigregister(setGaussian)


def gsl_vector_print(*args) -> "void" :
  return _libhmm.gsl_vector_print(*args)
gsl_vector_print = _libhmm.gsl_vector_print

def gsl_matrix_print(*args) -> "void" :
  return _libhmm.gsl_matrix_print(*args)
gsl_matrix_print = _libhmm.gsl_matrix_print

def gsl_pca(*args) -> "gsl_matrix *" :
  return _libhmm.gsl_pca(*args)
gsl_pca = _libhmm.gsl_pca
class Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    def __init__(self, *args): 
        this = _libhmm.new_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_Vector
    __del__ = lambda self : None;
    def size(self) -> "unsigned int" : return _libhmm.Vector_size(self)
    def get_vector(self) -> "gsl_vector *" : return _libhmm.Vector_get_vector(self)
    def __getitem__(self, *args) -> "double" : return _libhmm.Vector___getitem__(self, *args)
    def __call__(self, *args) -> "void" : return _libhmm.Vector___call__(self, *args)
    def __eq__(self, *args) -> "bool" : return _libhmm.Vector___eq__(self, *args)
    def assign(self, *args) -> "void" : return _libhmm.Vector_assign(self, *args)
    def __add__(self, *args) -> "Vector" : return _libhmm.Vector___add__(self, *args)
    def __iadd__(self, *args) -> "Vector &" : return _libhmm.Vector___iadd__(self, *args)
    def __sub__(self, *args) -> "Vector" : return _libhmm.Vector___sub__(self, *args)
    def __isub__(self, *args) -> "Vector &" : return _libhmm.Vector___isub__(self, *args)
    def __div__(self, *args) -> "Vector" : return _libhmm.Vector___div__(self, *args)
    def __idiv__(self, *args) -> "Vector &" : return _libhmm.Vector___idiv__(self, *args)
    def __mul__(self, *args) -> "Vector" : return _libhmm.Vector___mul__(self, *args)
    def __imul__(self, *args) -> "Vector &" : return _libhmm.Vector___imul__(self, *args)
    def norm(self) -> "double" : return _libhmm.Vector_norm(self)
    def mean(self) -> "double" : return _libhmm.Vector_mean(self)
    def __repr__(self) -> "std::string" : return _libhmm.Vector___repr__(self)
Vector_swigregister = _libhmm.Vector_swigregister
Vector_swigregister(Vector)

class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    def __init__(self, *args): 
        this = _libhmm.new_Matrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_Matrix
    __del__ = lambda self : None;
    def get_m(self) -> "unsigned int" : return _libhmm.Matrix_get_m(self)
    def get_n(self) -> "unsigned int" : return _libhmm.Matrix_get_n(self)
    def get_matrix(self) -> "gsl_matrix *" : return _libhmm.Matrix_get_matrix(self)
    def __eq__(self, *args) -> "bool" : return _libhmm.Matrix___eq__(self, *args)
    def assign(self, *args) -> "void" : return _libhmm.Matrix_assign(self, *args)
    def __add__(self, *args) -> "Matrix" : return _libhmm.Matrix___add__(self, *args)
    def __iadd__(self, *args) -> "Matrix &" : return _libhmm.Matrix___iadd__(self, *args)
    def __sub__(self, *args) -> "Matrix" : return _libhmm.Matrix___sub__(self, *args)
    def __isub__(self, *args) -> "Matrix &" : return _libhmm.Matrix___isub__(self, *args)
    def __imul__(self, *args) -> "Matrix &" : return _libhmm.Matrix___imul__(self, *args)
    def __mul__(self, *args) -> "Vector" : return _libhmm.Matrix___mul__(self, *args)
    def __call__(self, *args) -> "void" : return _libhmm.Matrix___call__(self, *args)
    def det(self) -> "double" : return _libhmm.Matrix_det(self)
    def mean(self) -> "double" : return _libhmm.Matrix_mean(self)
    def diagonal(self) -> "bool" : return _libhmm.Matrix_diagonal(self)
    def diagonalize(self) -> "void" : return _libhmm.Matrix_diagonalize(self)
    def __repr__(self) -> "std::string" : return _libhmm.Matrix___repr__(self)
Matrix_swigregister = _libhmm.Matrix_swigregister
Matrix_swigregister(Matrix)

HTK_FORMAT = _libhmm.HTK_FORMAT
XML_FORMAT = _libhmm.XML_FORMAT
BORDER = _libhmm.BORDER
COVMIN = _libhmm.COVMIN
GAUSS_PUSH = _libhmm.GAUSS_PUSH

def gettag(*args) -> "std::string" :
  return _libhmm.gettag(*args)
gettag = _libhmm.gettag

def init() -> "void" :
  return _libhmm.init()
init = _libhmm.init

def execute(*args) -> "std::string" :
  return _libhmm.execute(*args)
execute = _libhmm.execute
class point_len(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, point_len, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, point_len, name)
    __repr__ = _swig_repr
    __swig_setmethods__["i"] = _libhmm.point_len_i_set
    __swig_getmethods__["i"] = _libhmm.point_len_i_get
    if _newclass:i = _swig_property(_libhmm.point_len_i_get, _libhmm.point_len_i_set)
    __swig_setmethods__["j"] = _libhmm.point_len_j_set
    __swig_getmethods__["j"] = _libhmm.point_len_j_get
    if _newclass:j = _swig_property(_libhmm.point_len_j_get, _libhmm.point_len_j_set)
    __swig_setmethods__["len"] = _libhmm.point_len_len_set
    __swig_getmethods__["len"] = _libhmm.point_len_len_get
    if _newclass:len = _swig_property(_libhmm.point_len_len_get, _libhmm.point_len_len_set)
    def __init__(self, *args): 
        this = _libhmm.new_point_len(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_point_len
    __del__ = lambda self : None;
point_len_swigregister = _libhmm.point_len_swigregister
point_len_swigregister(point_len)

MODELSET = _libhmm.MODELSET
MODEL = _libhmm.MODEL
STATE = _libhmm.STATE
STREAM = _libhmm.STREAM
GAUSSIAN = _libhmm.GAUSSIAN
SVECTOR = _libhmm.SVECTOR
TRANSMATRIX = _libhmm.TRANSMATRIX
SMATRIX = _libhmm.SMATRIX
SHARED = _libhmm.SHARED
HMMLAB_OBJECT = _libhmm.HMMLAB_OBJECT
class RCObj(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RCObj, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RCObj, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ref_num"] = _libhmm.RCObj_ref_num_set
    __swig_getmethods__["ref_num"] = _libhmm.RCObj_ref_num_get
    if _newclass:ref_num = _swig_property(_libhmm.RCObj_ref_num_get, _libhmm.RCObj_ref_num_set)
    def __init__(self): 
        this = _libhmm.new_RCObj()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_RCObj
    __del__ = lambda self : None;
    def inc_ref_num(self) -> "void" : return _libhmm.RCObj_inc_ref_num(self)
    def dec_ref_num(self) -> "void" : return _libhmm.RCObj_dec_ref_num(self)
RCObj_swigregister = _libhmm.RCObj_swigregister
RCObj_swigregister(RCObj)

class HMMLab_Object(RCObj):
    __swig_setmethods__ = {}
    for _s in [RCObj]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMMLab_Object, name, value)
    __swig_getmethods__ = {}
    for _s in [RCObj]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMMLab_Object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _libhmm.HMMLab_Object_name_set
    __swig_getmethods__["name"] = _libhmm.HMMLab_Object_name_get
    if _newclass:name = _swig_property(_libhmm.HMMLab_Object_name_get, _libhmm.HMMLab_Object_name_set)
    __swig_setmethods__["type"] = _libhmm.HMMLab_Object_type_set
    __swig_getmethods__["type"] = _libhmm.HMMLab_Object_type_get
    if _newclass:type = _swig_property(_libhmm.HMMLab_Object_type_get, _libhmm.HMMLab_Object_type_set)
    def __init__(self, *args): 
        this = _libhmm.new_HMMLab_Object(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_HMMLab_Object
    __del__ = lambda self : None;
HMMLab_Object_swigregister = _libhmm.HMMLab_Object_swigregister
HMMLab_Object_swigregister(HMMLab_Object)

class Shared(HMMLab_Object):
    __swig_setmethods__ = {}
    for _s in [HMMLab_Object]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Shared, name, value)
    __swig_getmethods__ = {}
    for _s in [HMMLab_Object]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Shared, name)
    __repr__ = _swig_repr
    __swig_setmethods__["modelset"] = _libhmm.Shared_modelset_set
    __swig_getmethods__["modelset"] = _libhmm.Shared_modelset_get
    if _newclass:modelset = _swig_property(_libhmm.Shared_modelset_get, _libhmm.Shared_modelset_set)
    def __init__(self, *args): 
        this = _libhmm.new_Shared(*args)
        try: self.this.append(this)
        except: self.this = this
    def inc_ref_num(self) -> "void" : return _libhmm.Shared_inc_ref_num(self)
    def dec_ref_num(self) -> "void" : return _libhmm.Shared_dec_ref_num(self)
    __swig_destroy__ = _libhmm.delete_Shared
    __del__ = lambda self : None;
Shared_swigregister = _libhmm.Shared_swigregister
Shared_swigregister(Shared)

class SVector(Shared,Vector):
    __swig_setmethods__ = {}
    for _s in [Shared,Vector]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVector, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared,Vector]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _libhmm.new_SVector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_SVector
    __del__ = lambda self : None;
SVector_swigregister = _libhmm.SVector_swigregister
SVector_swigregister(SVector)

class SMatrix(Shared,Matrix):
    __swig_setmethods__ = {}
    for _s in [Shared,Matrix]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared,Matrix]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SMatrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _libhmm.new_SMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_SMatrix
    __del__ = lambda self : None;
SMatrix_swigregister = _libhmm.SMatrix_swigregister
SMatrix_swigregister(SMatrix)

class Gaussian(Shared):
    __swig_setmethods__ = {}
    for _s in [Shared]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Gaussian, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Gaussian, name)
    __repr__ = _swig_repr
    __swig_setmethods__["index_distribution"] = _libhmm.Gaussian_index_distribution_set
    __swig_getmethods__["index_distribution"] = _libhmm.Gaussian_index_distribution_get
    if _newclass:index_distribution = _swig_property(_libhmm.Gaussian_index_distribution_get, _libhmm.Gaussian_index_distribution_set)
    __swig_setmethods__["gconst"] = _libhmm.Gaussian_gconst_set
    __swig_getmethods__["gconst"] = _libhmm.Gaussian_gconst_get
    if _newclass:gconst = _swig_property(_libhmm.Gaussian_gconst_get, _libhmm.Gaussian_gconst_set)
    __swig_setmethods__["mean"] = _libhmm.Gaussian_mean_set
    __swig_getmethods__["mean"] = _libhmm.Gaussian_mean_get
    if _newclass:mean = _swig_property(_libhmm.Gaussian_mean_get, _libhmm.Gaussian_mean_set)
    __swig_setmethods__["covariance"] = _libhmm.Gaussian_covariance_set
    __swig_getmethods__["covariance"] = _libhmm.Gaussian_covariance_get
    if _newclass:covariance = _swig_property(_libhmm.Gaussian_covariance_get, _libhmm.Gaussian_covariance_set)
    __swig_setmethods__["inv_covariance"] = _libhmm.Gaussian_inv_covariance_set
    __swig_getmethods__["inv_covariance"] = _libhmm.Gaussian_inv_covariance_get
    if _newclass:inv_covariance = _swig_property(_libhmm.Gaussian_inv_covariance_get, _libhmm.Gaussian_inv_covariance_set)
    __swig_setmethods__["my_data"] = _libhmm.Gaussian_my_data_set
    __swig_getmethods__["my_data"] = _libhmm.Gaussian_my_data_get
    if _newclass:my_data = _swig_property(_libhmm.Gaussian_my_data_get, _libhmm.Gaussian_my_data_set)
    def __init__(self, *args): 
        this = _libhmm.new_Gaussian(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_Gaussian
    __del__ = lambda self : None;
    def probability(self, *args) -> "double" : return _libhmm.Gaussian_probability(self, *args)
    def divide(self) -> "void" : return _libhmm.Gaussian_divide(self)
Gaussian_swigregister = _libhmm.Gaussian_swigregister
Gaussian_swigregister(Gaussian)

class Stream(Shared):
    __swig_setmethods__ = {}
    for _s in [Shared]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stream, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Stream, name)
    __repr__ = _swig_repr
    __swig_setmethods__["index_distribution"] = _libhmm.Stream_index_distribution_set
    __swig_getmethods__["index_distribution"] = _libhmm.Stream_index_distribution_get
    if _newclass:index_distribution = _swig_property(_libhmm.Stream_index_distribution_get, _libhmm.Stream_index_distribution_set)
    __swig_setmethods__["gaussians"] = _libhmm.Stream_gaussians_set
    __swig_getmethods__["gaussians"] = _libhmm.Stream_gaussians_get
    if _newclass:gaussians = _swig_property(_libhmm.Stream_gaussians_get, _libhmm.Stream_gaussians_set)
    __swig_setmethods__["gaussians_weights"] = _libhmm.Stream_gaussians_weights_set
    __swig_getmethods__["gaussians_weights"] = _libhmm.Stream_gaussians_weights_get
    if _newclass:gaussians_weights = _swig_property(_libhmm.Stream_gaussians_weights_get, _libhmm.Stream_gaussians_weights_set)
    def __init__(self, *args): 
        this = _libhmm.new_Stream(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_Stream
    __del__ = lambda self : None;
    def add_gaussian(self, *args) -> "void" : return _libhmm.Stream_add_gaussian(self, *args)
    def remove_gaussian(self, *args) -> "void" : return _libhmm.Stream_remove_gaussian(self, *args)
    def get_gaussian_weight(self, *args) -> "double" : return _libhmm.Stream_get_gaussian_weight(self, *args)
    def probability(self, *args) -> "double" : return _libhmm.Stream_probability(self, *args)
Stream_swigregister = _libhmm.Stream_swigregister
Stream_swigregister(Stream)

class State(Shared):
    __swig_setmethods__ = {}
    for _s in [Shared]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, State, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, State, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _libhmm.State_x_set
    __swig_getmethods__["x"] = _libhmm.State_x_get
    if _newclass:x = _swig_property(_libhmm.State_x_get, _libhmm.State_x_set)
    __swig_setmethods__["y"] = _libhmm.State_y_set
    __swig_getmethods__["y"] = _libhmm.State_y_get
    if _newclass:y = _swig_property(_libhmm.State_y_get, _libhmm.State_y_set)
    __swig_setmethods__["streams"] = _libhmm.State_streams_set
    __swig_getmethods__["streams"] = _libhmm.State_streams_get
    if _newclass:streams = _swig_property(_libhmm.State_streams_get, _libhmm.State_streams_set)
    __swig_setmethods__["stream_weights"] = _libhmm.State_stream_weights_set
    __swig_getmethods__["stream_weights"] = _libhmm.State_stream_weights_get
    if _newclass:stream_weights = _swig_property(_libhmm.State_stream_weights_get, _libhmm.State_stream_weights_set)
    def __init__(self, *args): 
        this = _libhmm.new_State(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_State
    __del__ = lambda self : None;
    def select_gaussians(self, *args) -> "void" : return _libhmm.State_select_gaussians(self, *args)
    def unselect_gaussians(self, *args) -> "void" : return _libhmm.State_unselect_gaussians(self, *args)
    def get_gaussian(self, *args) -> "Gaussian *" : return _libhmm.State_get_gaussian(self, *args)
    def has_gaussian(self, *args) -> "bool" : return _libhmm.State_has_gaussian(self, *args)
    def in_viterbi_data(self, *args) -> "bool" : return _libhmm.State_in_viterbi_data(self, *args)
    def clear_viterbi_data(self) -> "void" : return _libhmm.State_clear_viterbi_data(self)
    def add_viterbi_data(self, *args) -> "void" : return _libhmm.State_add_viterbi_data(self, *args)
    def probability(self, *args) -> "double" : return _libhmm.State_probability(self, *args)
State_swigregister = _libhmm.State_swigregister
State_swigregister(State)

class TransMatrix(Shared):
    __swig_setmethods__ = {}
    for _s in [Shared]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [Shared]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransMatrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _libhmm.new_TransMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_TransMatrix
    __del__ = lambda self : None;
    def __call__(self, *args) -> "void" : return _libhmm.TransMatrix___call__(self, *args)
    def inc(self) -> "void" : return _libhmm.TransMatrix_inc(self)
    def remove(self, *args) -> "void" : return _libhmm.TransMatrix_remove(self, *args)
    def remove_matrix(self, *args) -> "void" : return _libhmm.TransMatrix_remove_matrix(self, *args)
    def add_matrix(self, *args) -> "void" : return _libhmm.TransMatrix_add_matrix(self, *args)
TransMatrix_swigregister = _libhmm.TransMatrix_swigregister
TransMatrix_swigregister(TransMatrix)

class Model(HMMLab_Object):
    __swig_setmethods__ = {}
    for _s in [HMMLab_Object]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    for _s in [HMMLab_Object]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    __swig_setmethods__["modelset"] = _libhmm.Model_modelset_set
    __swig_getmethods__["modelset"] = _libhmm.Model_modelset_get
    if _newclass:modelset = _swig_property(_libhmm.Model_modelset_get, _libhmm.Model_modelset_set)
    __swig_setmethods__["states"] = _libhmm.Model_states_set
    __swig_getmethods__["states"] = _libhmm.Model_states_get
    if _newclass:states = _swig_property(_libhmm.Model_states_get, _libhmm.Model_states_set)
    __swig_setmethods__["trans_mat"] = _libhmm.Model_trans_mat_set
    __swig_getmethods__["trans_mat"] = _libhmm.Model_trans_mat_get
    if _newclass:trans_mat = _swig_property(_libhmm.Model_trans_mat_get, _libhmm.Model_trans_mat_set)
    def __init__(self, *args): 
        this = _libhmm.new_Model(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_Model
    __del__ = lambda self : None;
    def add_state(self, *args) -> "void" : return _libhmm.Model_add_state(self, *args)
    def remove_state(self, *args) -> "void" : return _libhmm.Model_remove_state(self, *args)
    def select_gaussians(self) -> "void" : return _libhmm.Model_select_gaussians(self)
    def unselect_gaussians(self) -> "void" : return _libhmm.Model_unselect_gaussians(self)
    def create_image(self) -> "std::string" : return _libhmm.Model_create_image(self)
    def viterbi(self) -> "void" : return _libhmm.Model_viterbi(self)
Model_swigregister = _libhmm.Model_swigregister
Model_swigregister(Model)

class StreamArea(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamArea, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamArea, name)
    __repr__ = _swig_repr
    __swig_setmethods__["modelset"] = _libhmm.StreamArea_modelset_set
    __swig_getmethods__["modelset"] = _libhmm.StreamArea_modelset_get
    if _newclass:modelset = _swig_property(_libhmm.StreamArea_modelset_get, _libhmm.StreamArea_modelset_set)
    __swig_setmethods__["data"] = _libhmm.StreamArea_data_set
    __swig_getmethods__["data"] = _libhmm.StreamArea_data_get
    if _newclass:data = _swig_property(_libhmm.StreamArea_data_get, _libhmm.StreamArea_data_set)
    __swig_setmethods__["pos_data"] = _libhmm.StreamArea_pos_data_set
    __swig_getmethods__["pos_data"] = _libhmm.StreamArea_pos_data_get
    if _newclass:pos_data = _swig_property(_libhmm.StreamArea_pos_data_get, _libhmm.StreamArea_pos_data_set)
    __swig_setmethods__["pos_gaussians"] = _libhmm.StreamArea_pos_gaussians_set
    __swig_getmethods__["pos_gaussians"] = _libhmm.StreamArea_pos_gaussians_get
    if _newclass:pos_gaussians = _swig_property(_libhmm.StreamArea_pos_gaussians_get, _libhmm.StreamArea_pos_gaussians_set)
    __swig_setmethods__["pos_data_pca"] = _libhmm.StreamArea_pos_data_pca_set
    __swig_getmethods__["pos_data_pca"] = _libhmm.StreamArea_pos_data_pca_get
    if _newclass:pos_data_pca = _swig_property(_libhmm.StreamArea_pos_data_pca_get, _libhmm.StreamArea_pos_data_pca_set)
    __swig_setmethods__["pos_gaussians_pca"] = _libhmm.StreamArea_pos_gaussians_pca_set
    __swig_getmethods__["pos_gaussians_pca"] = _libhmm.StreamArea_pos_gaussians_pca_get
    if _newclass:pos_gaussians_pca = _swig_property(_libhmm.StreamArea_pos_gaussians_pca_get, _libhmm.StreamArea_pos_gaussians_pca_set)
    __swig_setmethods__["pos_gaussians_var_pca"] = _libhmm.StreamArea_pos_gaussians_var_pca_set
    __swig_getmethods__["pos_gaussians_var_pca"] = _libhmm.StreamArea_pos_gaussians_var_pca_get
    if _newclass:pos_gaussians_var_pca = _swig_property(_libhmm.StreamArea_pos_gaussians_var_pca_get, _libhmm.StreamArea_pos_gaussians_var_pca_set)
    __swig_setmethods__["pos_data_prob"] = _libhmm.StreamArea_pos_data_prob_set
    __swig_getmethods__["pos_data_prob"] = _libhmm.StreamArea_pos_data_prob_get
    if _newclass:pos_data_prob = _swig_property(_libhmm.StreamArea_pos_data_prob_get, _libhmm.StreamArea_pos_data_prob_set)
    __swig_setmethods__["pos_gaussians_prob"] = _libhmm.StreamArea_pos_gaussians_prob_set
    __swig_getmethods__["pos_gaussians_prob"] = _libhmm.StreamArea_pos_gaussians_prob_get
    if _newclass:pos_gaussians_prob = _swig_property(_libhmm.StreamArea_pos_gaussians_prob_get, _libhmm.StreamArea_pos_gaussians_prob_set)
    __swig_setmethods__["selected_gaussians"] = _libhmm.StreamArea_selected_gaussians_set
    __swig_getmethods__["selected_gaussians"] = _libhmm.StreamArea_selected_gaussians_get
    if _newclass:selected_gaussians = _swig_property(_libhmm.StreamArea_selected_gaussians_get, _libhmm.StreamArea_selected_gaussians_set)
    def __init__(self, *args): 
        this = _libhmm.new_StreamArea(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_StreamArea
    __del__ = lambda self : None;
    def get_data(self, *args) -> "Vector *" : return _libhmm.StreamArea_get_data(self, *args)
    def add_data(self, *args) -> "void" : return _libhmm.StreamArea_add_data(self, *args)
    def set_wh(self, *args) -> "void" : return _libhmm.StreamArea_set_wh(self, *args)
    def reset_pos_gauss(self) -> "void" : return _libhmm.StreamArea_reset_pos_gauss(self)
    def calc_pca(self) -> "void" : return _libhmm.StreamArea_calc_pca(self)
    def get_data_2D(self, *args) -> "List< Vector * >" : return _libhmm.StreamArea_get_data_2D(self, *args)
    def calc_data_gauss(self) -> "void" : return _libhmm.StreamArea_calc_data_gauss(self)
StreamArea_swigregister = _libhmm.StreamArea_swigregister
StreamArea_swigregister(StreamArea)

class ModelSet(HMMLab_Object):
    __swig_setmethods__ = {}
    for _s in [HMMLab_Object]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelSet, name, value)
    __swig_getmethods__ = {}
    for _s in [HMMLab_Object]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelSet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dimension"] = _libhmm.ModelSet_dimension_set
    __swig_getmethods__["dimension"] = _libhmm.ModelSet_dimension_get
    if _newclass:dimension = _swig_property(_libhmm.ModelSet_dimension_get, _libhmm.ModelSet_dimension_set)
    __swig_setmethods__["streams_size"] = _libhmm.ModelSet_streams_size_set
    __swig_getmethods__["streams_size"] = _libhmm.ModelSet_streams_size_get
    if _newclass:streams_size = _swig_property(_libhmm.ModelSet_streams_size_get, _libhmm.ModelSet_streams_size_set)
    __swig_setmethods__["streams_distribution"] = _libhmm.ModelSet_streams_distribution_set
    __swig_getmethods__["streams_distribution"] = _libhmm.ModelSet_streams_distribution_get
    if _newclass:streams_distribution = _swig_property(_libhmm.ModelSet_streams_distribution_get, _libhmm.ModelSet_streams_distribution_set)
    __swig_setmethods__["models"] = _libhmm.ModelSet_models_set
    __swig_getmethods__["models"] = _libhmm.ModelSet_models_get
    if _newclass:models = _swig_property(_libhmm.ModelSet_models_get, _libhmm.ModelSet_models_set)
    __swig_setmethods__["objects_dict"] = _libhmm.ModelSet_objects_dict_set
    __swig_getmethods__["objects_dict"] = _libhmm.ModelSet_objects_dict_get
    if _newclass:objects_dict = _swig_property(_libhmm.ModelSet_objects_dict_get, _libhmm.ModelSet_objects_dict_set)
    __swig_setmethods__["vecsize_tags"] = _libhmm.ModelSet_vecsize_tags_set
    __swig_getmethods__["vecsize_tags"] = _libhmm.ModelSet_vecsize_tags_get
    if _newclass:vecsize_tags = _swig_property(_libhmm.ModelSet_vecsize_tags_get, _libhmm.ModelSet_vecsize_tags_set)
    __swig_setmethods__["stream_areas"] = _libhmm.ModelSet_stream_areas_set
    __swig_getmethods__["stream_areas"] = _libhmm.ModelSet_stream_areas_get
    if _newclass:stream_areas = _swig_property(_libhmm.ModelSet_stream_areas_get, _libhmm.ModelSet_stream_areas_set)
    __swig_setmethods__["drawarea_models"] = _libhmm.ModelSet_drawarea_models_set
    __swig_getmethods__["drawarea_models"] = _libhmm.ModelSet_drawarea_models_get
    if _newclass:drawarea_models = _swig_property(_libhmm.ModelSet_drawarea_models_get, _libhmm.ModelSet_drawarea_models_set)
    __swig_setmethods__["files_data"] = _libhmm.ModelSet_files_data_set
    __swig_getmethods__["files_data"] = _libhmm.ModelSet_files_data_get
    if _newclass:files_data = _swig_property(_libhmm.ModelSet_files_data_get, _libhmm.ModelSet_files_data_set)
    def __init__(self, *args): 
        this = _libhmm.new_ModelSet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libhmm.delete_ModelSet
    __del__ = lambda self : None;
    def destroy(self) -> "void" : return _libhmm.ModelSet_destroy(self)
    def save(self, *args) -> "void" : return _libhmm.ModelSet_save(self, *args)
    def load_data(self, *args) -> "void" : return _libhmm.ModelSet_load_data(self, *args)
    def reset_pos_gauss(self) -> "void" : return _libhmm.ModelSet_reset_pos_gauss(self)
    def add_model(self, *args) -> "void" : return _libhmm.ModelSet_add_model(self, *args)
    def remove_model(self, *args) -> "void" : return _libhmm.ModelSet_remove_model(self, *args)
    def is_selected(self, *args) -> "bool" : return _libhmm.ModelSet_is_selected(self, *args)
    def selected_gaussians_count(self) -> "unsigned int" : return _libhmm.ModelSet_selected_gaussians_count(self)
    def loaded_data_count(self) -> "unsigned int" : return _libhmm.ModelSet_loaded_data_count(self)
    def get_models_with_gaussian(self, *args) -> "List< Model * >" : return _libhmm.ModelSet_get_models_with_gaussian(self, *args)
    def get_unique_name(self, *args) -> "std::string" : return _libhmm.ModelSet_get_unique_name(self, *args)
    def gauss_cluster(self, *args) -> "bool" : return _libhmm.ModelSet_gauss_cluster(self, *args)
    def gauss_push(self, *args) -> "bool" : return _libhmm.ModelSet_gauss_push(self, *args)
    def get_model(self, *args) -> "Model *" : return _libhmm.ModelSet_get_model(self, *args)
    def get_state(self, *args) -> "State *" : return _libhmm.ModelSet_get_state(self, *args)
    def get_stream(self, *args) -> "Stream *" : return _libhmm.ModelSet_get_stream(self, *args)
    def get_gaussian(self, *args) -> "Gaussian *" : return _libhmm.ModelSet_get_gaussian(self, *args)
    def get_svector(self, *args) -> "SVector *" : return _libhmm.ModelSet_get_svector(self, *args)
    def get_smatrix(self, *args) -> "SMatrix *" : return _libhmm.ModelSet_get_smatrix(self, *args)
    def gnuplot_2D(self, *args) -> "void" : return _libhmm.ModelSet_gnuplot_2D(self, *args)
ModelSet_swigregister = _libhmm.ModelSet_swigregister
ModelSet_swigregister(ModelSet)

# This file is compatible with both classic and new-style classes.


